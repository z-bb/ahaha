spark调优方面

[TOC]



# 数据序列化

序列化在任何分布式应用程序的性能中都起着重要的作用。将对象序列化为大量字节的格式将大大降低计算速度。因此，选择合适的序列化方式将是优化程序的第一件事。`spark`旨在在便利性(允许在操作中使用任何的`java`类型)和性能之间取得平衡，提供了两种序列化库。

`Java`序列化：默认情况下，`spark`允许使用`java`的`ObjectOutputStream`框架序列化对象，并且可以与程序中创建的任何实现`java.io.Serializable`的类一起使用。还可以通过扩展`java.io.Externalizable`来更紧密地控制序列化的性能。`java`序列化时灵活的，但通常很慢，并导致许多大型序列化格式的类。

`kryo`序列化：`spark`还可以使用`kryo`库更快地序列化对象。`kryo`比`java`序列化(通常高达10倍)明显更快，更紧凑，但不支持所有`Serializable`类型，并且要求提前注册在程序中使用的类以获得最佳性能。

通过使用`sparkConf`初始化作业并调用`conf.set("spark.serializer", "org.apache.spark.serializer.kryoSerializer")`来使用`kryo`序列化方式。该设置的序列化方式，不仅用于在`work`节点之间数据`shuffle`，还用于将`RDD`序列化到磁盘。`kryo`不是默认的唯一原因是因为需要自定义注册要求。从`spark 2.0.0`开始，在使用简单类型，简单类型数组或字符串类型对`RDD`进行数据`shuffle`，内部使用`kryo`进行序列化。

`spark`自动包含`kryo`序列化器，用于`Twitter chill`库中`AllscalaRegistrar`涵盖的许多常用核心`scala`库。

要使用`kryo`注册自己的自定义类，需要使用`registerKryoClasses`方法

```scala
val conf = new SparkConf().setMaster(...).setAppName(...)
conf.registerKryoClasses(Array(classof[MyClass1], classof[Myclass2]))
val sc = new SparkContext(conf)
```

如果需要注册的对象很大的时候，可以通过增加`spark.kryoserializer.buffer`的大小来容纳允许的序列化对象的大小。

如果没有注册自定义类，`kryo`仍会工作，但它必须存储每个对象的完整类名，这是一种浪费！

# 内存调整

内存优化有三个方面的考虑：对象所占的内存，访问对象的成本以及垃圾回收所占的开销。

默认情况下，`java`对象访问速度很快，但与其“原始”数据相比，可以轻松占用2-5倍的空间。这是由于一下几个原因：

- 每个不同的`java`对象都有一个”对象头“，大约16个字节，并包含诸如指向该类的指针之类的信息。对于其中包含非常少数据的对象(比如一个`int`字段)，这可能比数据大。
- `java String`比原始字符串数据上有大约40个字节的开销(因为它们将它存储在一个`char`数组中并保留额外的数据，如长度)，并且由于`String`内部使用`UTF-16`编码，一个字符需要占用两个字节，因此一个长度为10字节的字符串需要60个字节。
- 公共集合类，例如`HashMap`和`LinkedList`，使用链表数据结构，其中每个节点都有一个“包装”对象(例如`Map.Entry`)。此对象不仅包含“对象头”，还具有指向列表中下一个对象的指针(通常每个指针占8个字节)。
- 原始类型的集合通常将它们存储为“装箱”对象，例如`java.lang.Integer`。

## 内存管理概述

`spark`中的内存使用大致分为两类：`execution`和`storage`。`execution`内存是用于`shuffle`、`join`、`sort`、`aggregation`计算的内存，而`storage`内存是用于在集群中`cache`和`broadcast`内部数据的内存。在`spark`中，`execution`和`storage`共享一个统一的区域(`M`)。当没有使用`execution`内存时，`storage`可以获取所有可用的内存，反之亦然。如有必要，`execution`可以驱逐`storage`，但仅限于总存储内存使用量低于某个阈值(`R`)。换句话说，`R`描述了`M`从不驱逐缓存块的子区域。由于实现的复杂性，`storage`不会驱逐`execution`。

这种设计保证了几个显著的特征。首先，不使用缓冲的应用程序可以使用整个空间执行，从而避免不必要的磁盘溢出。其次，使用缓冲的应用程序可以保留最小存储空间(`R`)，其中数据块不受驱逐。最后，这种方法为各种工作负载提供了合理的开箱即用性能，而无需用户内部划分内存的专业知识。

虽然有两种相关配置，但大部分用户不需要调整他们，因为默认值适用于大多数工作负载：

- `spark.memory.fraction`表示大小`M`为（`JVM`堆空间 - `300MB`）的一小部分（默认值为0.6）。剩余的空间(0.4)保留用于数据结构，`spark`中内部元数据，防止在异常大而稀疏的记录下发生`OOM`错误。
- `spark.memory.storageFraction`表示`R`为`M`(默认为0.5)的一小部分。`R`是`M`缓冲块不受执行驱逐的存储空间。
- `spark.memory.fraction`值的配置不仅仅调试`JVM`堆空间或`trunred`设置。还有一些`GC`优化

## 确定内存消耗

调整数据集所需内存消耗量的最佳方式就是创建`RDD`，将其放入缓冲中，然后查看`web UI`中的“storage”页面。来确定`RDD`占用多少内存。

为了估计特定对象的内存消耗，使用`SizeEstimator`的`estimate`方法。这对于尝试使用不同的数据布局来调整内存使用情况以及确定广播变量在每个执行程序堆上占用的空间量非常有用。

## 数据结构优化

减少内存消耗的第一种方法是避免增加开销的`java`功能，例如基于指针的数据结构和包装器对象。有很多中方法：

1. 使用的数据结构优先选择对象数组和基本类型，而不是标准的`java`或`scala`集合类(例如`HashMap`)。`fastutil`库提供了原始数据类型非常方便的集合类，同时兼容`java`标准类库。
2. 尽可能避免使用包含大量小对象和指针的嵌套结构。
3. 考虑使用数据`ID`或枚举对象而不是`String`类型的主键。
4. 如果内存少于`32GB`，设置`Jvm`参数`-XX:+UseCompressedOops`来将8字节指针修改为4字节。

## 序列化RDD存储

当上面的优化都尝试了，但时当对象仍然太大而无法有效存储时，减少内存使用的一种更简单的方法是使用`RDD`持久化`API`中的序列化`StorageLevels`以序列化形式存储他们。`spark`将每个`RDD`分区存储为一个大字节数据。由于必须动态地反序列化每个对象，因此以序列化形式存储数据的唯一缺点是访问时间较慢。如果以序列化的形式缓冲数据，建议使用`kryo`，因为它占用的空间比`java`序列化小得多。

## 垃圾收集调整

序列化RDD存储

- `spark.memory.fraction`表示大小`M`