# 三种垃圾回收算法

## 标记-清除(`mark-sweep`)

1. 标记出所需回收的对象
2. 在标记完成后统一回收所有被标记的对象

### 缺点：

1. 每次进行垃圾回收的时候，会暂停当前用户线程的执行(`stw`)
2. 垃圾回收器需要间隔性的检查，并且标记和清除的过程相对较慢
3. 在标记清除之后可能产生大量的内存碎片，导致一旦需要为大对象分配空间时，由于找不到足够大的内存空间，而不得以引发另一次`gc`的执行

## 标记-复制(`mark-copy`)

1. 将可用的内存按找容量分为大小相等的两块，使用区和空闲区
2. 当这块内存用完了，就将还存活的对象复制到另外一个上面，然后再把已使用过的内存空间一次性清理掉

### 优点：

1. 不会产生内存碎片

### 缺点：

1. 原有的空间被缩小了一半，空间利用率降低
2. 标记复制算法在对象存活率较高的情况下要进行较多的对象复制操作，效率会变低
3. 垃圾回收过程也会暂停用户线程的执行

## 标记-整理(`mark-compact`)

1. 标记
2. 让所有存储的对象都向一端移动，然后直接清理掉端边界以外的内存

此算法结合了标记-清除和标记-复制的优点。也是分为两个阶段。第一个阶段从根节点开始标记所有被引用的对象，第二个阶段把为标记的对象压缩到堆的其中一块，按顺序排放。此算法避免了标记-清除的内存碎片问题，同时也避免了标记-复制的空间利用率问题

### 缺点：

1. 暂停当前应用的执行，非实时的回收



# 垃圾回收器

分代收集方法论--**不同的对象的生命周期时不一样的**

将对象按其生命周期的不同划分为**新生代**、**年老代**和**永久代**

其中永久代主要存放类的信息，所以与`java`对象的回收关系不大，与回收息息相关的是新生代和年老代



*新生代*：是所有对象产生的地方

*新生代*采用了**标记-复制**的算法

划分为三个部分`eden`和`survivor`区(`from`和`to`)比例为8:1:1

当`eden`区对象填满时，就会执行`minor gc`，并把所有存活的对象转移到其中一个`survivor`区。这样在一段时间内，总会有一个空的`survivor`区。经过多次`gc`周期后，仍然存活下来的对象会被移到年老代内存空间中。通常新生代有资格提升到年老代时通过设定的阈值来完成的



*年老代*：新生代经历了n次回收后仍没有被清除的对象

*年老代*采用**标记-整理算法**

在*年老代*内存被占满时通常会触发`full gc`，回收整个堆内存



*永久代*：存放静态文件，比如`java`类，方法等

*永久代*对垃圾回收没有显著的影响

​		     图1.jvm堆模型

![img](https://www.coder4.com/wp-content/uploads/2018/03/1.jpg)